<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;yoursite.com&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Muse&quot;,&quot;version&quot;:&quot;8.5.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;},&quot;path&quot;:&quot;&#x2F;search.xml&quot;,&quot;localsearch&quot;:{&quot;enable&quot;:true,&quot;trigger&quot;:&quot;auto&quot;,&quot;top_n_per_article&quot;:1,&quot;unescape&quot;:false,&quot;preload&quot;:false}}</script><script src="/js/config.js"></script>
<meta name="description" content="Kafka处理Fetch请求以及日志读取过程">
<meta property="og:type" content="article">
<meta property="og:title" content="Kafka源码系列之十一副本管理读取">
<meta property="og:url" content="http://yoursite.com/2020/05/08/Kafka%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8D%81%E4%B8%80%E5%89%AF%E6%9C%AC%E7%AE%A1%E7%90%86%E8%AF%BB%E5%8F%96/index.html">
<meta property="og:site_name" content="BlackC">
<meta property="og:description" content="Kafka处理Fetch请求以及日志读取过程">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-05-08T05:34:43.000Z">
<meta property="article:modified_time" content="2021-03-21T12:33:13.852Z">
<meta property="article:author" content="X&amp;Z">
<meta property="article:tag" content="kafka">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/2020/05/08/Kafka%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8D%81%E4%B8%80%E5%89%AF%E6%9C%AC%E7%AE%A1%E7%90%86%E8%AF%BB%E5%8F%96/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;05&#x2F;08&#x2F;Kafka%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8D%81%E4%B8%80%E5%89%AF%E6%9C%AC%E7%AE%A1%E7%90%86%E8%AF%BB%E5%8F%96&#x2F;&quot;,&quot;path&quot;:&quot;2020&#x2F;05&#x2F;08&#x2F;Kafka源码系列之十一副本管理读取&#x2F;&quot;,&quot;title&quot;:&quot;Kafka源码系列之十一副本管理读取&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>Kafka源码系列之十一副本管理读取 | BlackC</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">BlackC</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Fetch%E8%AF%B7%E6%B1%82%E7%9A%84%E6%9D%A5%E6%BA%90"><span class="nav-number">1.</span> <span class="nav-text">Fetch请求的来源</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Consumer%E6%9E%84%E5%BB%BA"><span class="nav-number">1.1.</span> <span class="nav-text">Consumer构建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReplicaFetchManager%E6%9E%84%E5%BB%BA"><span class="nav-number">1.2.</span> <span class="nav-text">ReplicaFetchManager构建</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Server%E7%AB%AF%E5%A4%84%E7%90%86Fetch%E8%AF%B7%E6%B1%82"><span class="nav-number">2.</span> <span class="nav-text">Server端处理Fetch请求</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#handleFetchRequest"><span class="nav-number">2.1.</span> <span class="nav-text">handleFetchRequest()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReplicaManager"><span class="nav-number">2.2.</span> <span class="nav-text">ReplicaManager</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#fetchMessages"><span class="nav-number">2.2.1.</span> <span class="nav-text">fetchMessages</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#readFromLocalLog-gt-readRecords"><span class="nav-number">2.2.2.</span> <span class="nav-text">readFromLocalLog()-&gt;readRecords()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%B1%82"><span class="nav-number">3.</span> <span class="nav-text">存储层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Log%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.1.</span> <span class="nav-text">Log对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#read"><span class="nav-number">3.1.1.</span> <span class="nav-text">read()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LogSegment%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.2.</span> <span class="nav-text">LogSegment对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#read-1"><span class="nav-number">3.2.1.</span> <span class="nav-text">read()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#translateOffset"><span class="nav-number">3.2.2.</span> <span class="nav-text">translateOffset()</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">X&Z</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">251</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/08/Kafka%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8D%81%E4%B8%80%E5%89%AF%E6%9C%AC%E7%AE%A1%E7%90%86%E8%AF%BB%E5%8F%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="X&Z">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BlackC">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Kafka源码系列之十一副本管理读取
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-05-08 13:34:43" itemprop="dateCreated datePublished" datetime="2020-05-08T13:34:43+08:00">2020-05-08</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-21 20:33:13" itemprop="dateModified" datetime="2021-03-21T20:33:13+08:00">2021-03-21</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <blockquote>
<p>Kafka处理Fetch请求以及日志读取过程</p>
</blockquote>
<span id="more"></span>

<h2 id="Fetch请求的来源"><a href="#Fetch请求的来源" class="headerlink" title="Fetch请求的来源"></a>Fetch请求的来源</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.Consumer消费数据产生Fetch请求</span><br><span class="line">    Consumer产生Fetch请求在之前有说过,在poll方法中构建</span><br><span class="line">2.副本同步Fetch请求</span><br><span class="line">    ReplicaManager中有一个ReplicaFetchManager实例负责开启FetchThread进行Fetch请求构建</span><br><span class="line"></span><br><span class="line">两者的区别:</span><br><span class="line">    Replica在构造FetchRequest时,调用了setReplicaId()设置了对应的replicaId</span><br><span class="line">    Consumer没有进行设置,默认为CONSUMER_REPLICA_ID,为-1</span><br><span class="line">    这个值就是区分Consumer的Fetch请求和Replica的Fetch请求的关键值</span><br></pre></td></tr></table></figure>
<h3 id="Consumer构建"><a href="#Consumer构建" class="headerlink" title="Consumer构建"></a>Consumer构建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fetcher.sendFetches()</span></span><br><span class="line"><span class="keyword">final</span> FetchRequest.Builder request = FetchRequest.Builder</span><br><span class="line">        .forConsumer(<span class="keyword">this</span>.maxWaitMs, <span class="keyword">this</span>.minBytes, data.toSend())</span><br><span class="line">        .isolationLevel(isolationLevel)</span><br><span class="line">        .setMaxBytes(<span class="keyword">this</span>.maxBytes)</span><br><span class="line">        .metadata(data.metadata())</span><br><span class="line">        .toForget(data.toForget());</span><br></pre></td></tr></table></figure>
<h3 id="ReplicaFetchManager构建"><a href="#ReplicaFetchManager构建" class="headerlink" title="ReplicaFetchManager构建"></a>ReplicaFetchManager构建</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReplicaFetcherThread.buildFetch()</span></span><br><span class="line"><span class="keyword">val</span> fetchData = builder.build()</span><br><span class="line"><span class="keyword">val</span> fetchRequestOpt = <span class="keyword">if</span> (fetchData.sessionPartitions.isEmpty &amp;&amp; fetchData.toForget.isEmpty) &#123;</span><br><span class="line">  <span class="type">None</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">val</span> requestBuilder = <span class="type">FetchRequest</span>.<span class="type">Builder</span></span><br><span class="line">    .forReplica(fetchRequestVersion, replicaId, maxWait, minBytes, fetchData.toSend)</span><br><span class="line">    .setMaxBytes(maxBytes)</span><br><span class="line">    .toForget(fetchData.toForget)</span><br><span class="line">    .metadata(fetchData.metadata)</span><br><span class="line">  <span class="type">Some</span>(requestBuilder)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Server端处理Fetch请求"><a href="#Server端处理Fetch请求" class="headerlink" title="Server端处理Fetch请求"></a>Server端处理Fetch请求</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApiKeys.FETCH -&gt; handleFetchRequest()</span><br></pre></td></tr></table></figure>
<h3 id="handleFetchRequest"><a href="#handleFetchRequest" class="headerlink" title="handleFetchRequest()"></a>handleFetchRequest()</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleFetchRequest</span></span>(request: <span class="type">RequestChannel</span>.<span class="type">Request</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> versionId = request.header.apiVersion</span><br><span class="line">    <span class="keyword">val</span> clientId = request.header.clientId</span><br><span class="line">    <span class="keyword">val</span> fetchRequest = request.body[<span class="type">FetchRequest</span>]</span><br><span class="line">    <span class="keyword">val</span> fetchContext = fetchManager.newContext(</span><br><span class="line">      fetchRequest.metadata,</span><br><span class="line">      fetchRequest.fetchData,</span><br><span class="line">      fetchRequest.toForget,</span><br><span class="line">      fetchRequest.isFromFollower)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检验错误的请求</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">errorResponse</span></span>[<span class="type">T</span> &gt;: <span class="type">MemoryRecords</span> &lt;: <span class="type">BaseRecords</span>](error: <span class="type">Errors</span>): <span class="type">FetchResponse</span>.<span class="type">PartitionData</span>[<span class="type">T</span>] = &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="type">FetchResponse</span>.<span class="type">PartitionData</span>[<span class="type">T</span>](error, <span class="type">FetchResponse</span>.<span class="type">INVALID_HIGHWATERMARK</span>, <span class="type">FetchResponse</span>.<span class="type">INVALID_LAST_STABLE_OFFSET</span>,</span><br><span class="line">        <span class="type">FetchResponse</span>.<span class="type">INVALID_LOG_START_OFFSET</span>, <span class="literal">null</span>, <span class="type">MemoryRecords</span>.<span class="type">EMPTY</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> erroneous = mutable.<span class="type">ArrayBuffer</span>[(<span class="type">TopicPartition</span>, <span class="type">FetchResponse</span>.<span class="type">PartitionData</span>[<span class="type">Records</span>])]()</span><br><span class="line">    <span class="keyword">val</span> interesting = mutable.<span class="type">ArrayBuffer</span>[(<span class="type">TopicPartition</span>, <span class="type">FetchRequest</span>.<span class="type">PartitionData</span>)]()</span><br><span class="line">    <span class="keyword">if</span> (fetchRequest.isFromFollower) &#123;</span><br><span class="line">      <span class="comment">// The follower must have ClusterAction on ClusterResource in order to fetch partition data.</span></span><br><span class="line">      <span class="comment">// 检验tp是否存在以及是否有Describe权限</span></span><br><span class="line">      <span class="keyword">if</span> (authorize(request.session, <span class="type">ClusterAction</span>, <span class="type">Resource</span>.<span class="type">ClusterResource</span>)) &#123;</span><br><span class="line">        fetchContext.foreachPartition &#123; (topicPartition, data) =&gt;</span><br><span class="line">          <span class="comment">// 不存在或没有Describe权限的topic,返回UNKNOWN_TOPIC_OR_PARTITION错误</span></span><br><span class="line">          <span class="keyword">if</span> (!metadataCache.contains(topicPartition))</span><br><span class="line">            erroneous += topicPartition -&gt; errorResponse(<span class="type">Errors</span>.<span class="type">UNKNOWN_TOPIC_OR_PARTITION</span>)</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            interesting += (topicPartition -&gt; data)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没有ClusterAction权限,返回TOPIC_AUTHORIZATION_FAILED错误</span></span><br><span class="line">        fetchContext.foreachPartition &#123; (part, _) =&gt;</span><br><span class="line">          erroneous += part -&gt; errorResponse(<span class="type">Errors</span>.<span class="type">TOPIC_AUTHORIZATION_FAILED</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fetchContext.foreachPartition &#123; (topicPartition, data) =&gt;</span><br><span class="line">        <span class="keyword">if</span> (!authorize(request.session, <span class="type">Read</span>, <span class="type">Resource</span>(<span class="type">Topic</span>, topicPartition.topic, <span class="type">LITERAL</span>)))</span><br><span class="line">          <span class="comment">// 没有read权限,返回TOPIC_AUTHORIZATION_FAILED错误</span></span><br><span class="line">          erroneous += topicPartition -&gt; errorResponse(<span class="type">Errors</span>.<span class="type">TOPIC_AUTHORIZATION_FAILED</span>)</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!metadataCache.contains(topicPartition))</span><br><span class="line">          <span class="comment">// 不存在或没有Describe权限的topic,返回UNKNOWN_TOPIC_OR_PARTITION错误</span></span><br><span class="line">          erroneous += topicPartition -&gt; errorResponse(<span class="type">Errors</span>.<span class="type">UNKNOWN_TOPIC_OR_PARTITION</span>)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          interesting += (topicPartition -&gt; data)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (interesting.isEmpty)</span><br><span class="line">      processResponseCallback(<span class="type">Seq</span>.empty)</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// call the replica manager to fetch messages from the local replica</span></span><br><span class="line">      <span class="comment">// 从replica上拉取数据,满足条件后调用函数进行返回</span></span><br><span class="line">      replicaManager.fetchMessages(</span><br><span class="line">        fetchRequest.maxWait.toLong, <span class="comment">// 拉取请求最长等待时间</span></span><br><span class="line">        fetchRequest.replicaId, <span class="comment">// ReplicaId,Consumer的为-1</span></span><br><span class="line">        fetchRequest.minBytes, <span class="comment">// 拉取请求的最小拉取字节</span></span><br><span class="line">        fetchRequest.maxBytes, <span class="comment">// 拉取请求的最大拉取字节</span></span><br><span class="line">        versionId &lt;= <span class="number">2</span>,</span><br><span class="line">        interesting,</span><br><span class="line">        replicationQuota(fetchRequest),</span><br><span class="line">        processResponseCallback,</span><br><span class="line">        fetchRequest.isolationLevel)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ReplicaManager"><a href="#ReplicaManager" class="headerlink" title="ReplicaManager"></a>ReplicaManager</h3><h4 id="fetchMessages"><a href="#fetchMessages" class="headerlink" title="fetchMessages"></a>fetchMessages</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>readFromLocalLog(): 从本地日志拉取相应的数据</span><br><span class="line"><span class="number">2.</span>判断<span class="type">Fetch</span>请求来源,如果来自副本同步,那么更新该副本的the end offset记录,如果该副本不在isr中,判断是否需要更新isr</span><br><span class="line"><span class="number">3.</span>返回结果,满足条件立即返回,否则通过延迟操作,延迟返回结果</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从leader拉取数据,等待拉取到足够的数据或者达到timeout时间后返回拉取的结果</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetchMessages</span></span>(timeout: <span class="type">Long</span>,</span><br><span class="line">                    replicaId: <span class="type">Int</span>,</span><br><span class="line">                    fetchMinBytes: <span class="type">Int</span>,</span><br><span class="line">                    fetchMaxBytes: <span class="type">Int</span>,</span><br><span class="line">                    hardMaxBytesLimit: <span class="type">Boolean</span>,</span><br><span class="line">                    fetchInfos: <span class="type">Seq</span>[(<span class="type">TopicPartition</span>, <span class="type">PartitionData</span>)],</span><br><span class="line">                    quota: <span class="type">ReplicaQuota</span> = <span class="type">UnboundedQuota</span>,</span><br><span class="line">                    responseCallback: <span class="type">Seq</span>[(<span class="type">TopicPartition</span>, <span class="type">FetchPartitionData</span>)] =&gt; <span class="type">Unit</span>,</span><br><span class="line">                    isolationLevel: <span class="type">IsolationLevel</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断请求时来自consumer还是副本同步</span></span><br><span class="line">    <span class="keyword">val</span> isFromFollower = <span class="type">Request</span>.isValidBrokerId(replicaId)</span><br><span class="line">    <span class="comment">// 默认从leader拉取</span></span><br><span class="line">    <span class="keyword">val</span> fetchOnlyFromLeader = replicaId != <span class="type">Request</span>.<span class="type">DebuggingConsumerId</span> &amp;&amp; replicaId != <span class="type">Request</span>.<span class="type">FutureLocalReplicaId</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果拉取请求来自consumer(true),只拉取HW以内的数据</span></span><br><span class="line">    <span class="comment">// 如果来自Replica,则没有限制</span></span><br><span class="line">    <span class="keyword">val</span> fetchIsolation = <span class="keyword">if</span> (isFromFollower || replicaId == <span class="type">Request</span>.<span class="type">FutureLocalReplicaId</span>)</span><br><span class="line">      <span class="type">FetchLogEnd</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isolationLevel == <span class="type">IsolationLevel</span>.<span class="type">READ_COMMITTED</span>)</span><br><span class="line">      <span class="type">FetchTxnCommitted</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="type">FetchHighWatermark</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">readFromLog</span></span>(): <span class="type">Seq</span>[(<span class="type">TopicPartition</span>, <span class="type">LogReadResult</span>)] = &#123;</span><br><span class="line">      <span class="comment">// 获取本地日志</span></span><br><span class="line">      <span class="keyword">val</span> result = readFromLocalLog(</span><br><span class="line">        replicaId = replicaId,</span><br><span class="line">        fetchOnlyFromLeader = fetchOnlyFromLeader,</span><br><span class="line">        fetchIsolation = fetchIsolation,</span><br><span class="line">        fetchMaxBytes = fetchMaxBytes,</span><br><span class="line">        hardMaxBytesLimit = hardMaxBytesLimit,</span><br><span class="line">        readPartitionInfo = fetchInfos,</span><br><span class="line">        quota = quota)</span><br><span class="line">      <span class="comment">// 如果fetch来自broker的副本同步,更新相关的log end offset</span></span><br><span class="line">      <span class="keyword">if</span> (isFromFollower) updateFollowerLogReadResults(replicaId, result)</span><br><span class="line">      <span class="keyword">else</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> logReadResults = readFromLog()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check if this fetch request can be satisfied right away</span></span><br><span class="line">    <span class="keyword">val</span> logReadResultValues = logReadResults.map &#123; <span class="keyword">case</span> (_, v) =&gt; v &#125;</span><br><span class="line">    <span class="keyword">val</span> bytesReadable = logReadResultValues.map(_.info.records.sizeInBytes).sum</span><br><span class="line">    <span class="keyword">val</span> errorReadingData = logReadResultValues.foldLeft(<span class="literal">false</span>) ((errorIncurred, readResult) =&gt;</span><br><span class="line">      errorIncurred || (readResult.error != <span class="type">Errors</span>.<span class="type">NONE</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果满足以下条件的其中一个,立马返回结果</span></span><br><span class="line">    <span class="comment">// 1.timeout达到</span></span><br><span class="line">    <span class="comment">// 2.拉取结果为空</span></span><br><span class="line">    <span class="comment">// 3.拉取到足够的数据</span></span><br><span class="line">    <span class="comment">// 4.拉取时遇到Error</span></span><br><span class="line">    <span class="keyword">if</span> (timeout &lt;= <span class="number">0</span> || fetchInfos.isEmpty || bytesReadable &gt;= fetchMinBytes || errorReadingData) &#123;</span><br><span class="line">      <span class="keyword">val</span> fetchPartitionData = logReadResults.map &#123; <span class="keyword">case</span> (tp, result) =&gt;</span><br><span class="line">        tp -&gt; <span class="type">FetchPartitionData</span>(result.error, result.highWatermark, result.leaderLogStartOffset, result.info.records,</span><br><span class="line">          result.lastStableOffset, result.info.abortedTransactions)</span><br><span class="line">      &#125;</span><br><span class="line">      responseCallback(fetchPartitionData)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// construct the fetch results from the read results</span></span><br><span class="line">      <span class="comment">// 延迟发送结果</span></span><br><span class="line">      <span class="keyword">val</span> fetchPartitionStatus = logReadResults.map &#123; <span class="keyword">case</span> (topicPartition, result) =&gt;</span><br><span class="line">        <span class="keyword">val</span> fetchInfo = fetchInfos.collectFirst &#123;</span><br><span class="line">          <span class="keyword">case</span> (tp, v) <span class="keyword">if</span> tp == topicPartition =&gt; v</span><br><span class="line">        &#125;.getOrElse(sys.error(<span class="string">s&quot;Partition <span class="subst">$topicPartition</span> not found in fetchInfos&quot;</span>))</span><br><span class="line">        (topicPartition, <span class="type">FetchPartitionStatus</span>(result.info.fetchOffsetMetadata, fetchInfo))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">val</span> fetchMetadata = <span class="type">FetchMetadata</span>(fetchMinBytes, fetchMaxBytes, hardMaxBytesLimit, fetchOnlyFromLeader,</span><br><span class="line">        fetchIsolation, isFromFollower, replicaId, fetchPartitionStatus)</span><br><span class="line">      <span class="keyword">val</span> delayedFetch = <span class="keyword">new</span> <span class="type">DelayedFetch</span>(timeout, fetchMetadata, <span class="keyword">this</span>, quota, responseCallback)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// create a list of (topic, partition) pairs to use as keys for this delayed fetch operation</span></span><br><span class="line">      <span class="keyword">val</span> delayedFetchKeys = fetchPartitionStatus.map &#123; <span class="keyword">case</span> (tp, _) =&gt; <span class="keyword">new</span> <span class="type">TopicPartitionOperationKey</span>(tp) &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// try to complete the request immediately, otherwise put it into the purgatory;</span></span><br><span class="line">      <span class="comment">// this is because while the delayed fetch operation is being created, new requests</span></span><br><span class="line">      <span class="comment">// may arrive and hence make this operation completable.</span></span><br><span class="line">      delayedFetchPurgatory.tryCompleteElseWatch(delayedFetch, delayedFetchKeys)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="readFromLocalLog-gt-readRecords"><a href="#readFromLocalLog-gt-readRecords" class="headerlink" title="readFromLocalLog()-&gt;readRecords()"></a>readFromLocalLog()-&gt;readRecords()</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>先根据要拉取的tp获取对应的partition对象,根据partition对象获取对应的<span class="type">Replica</span>对象</span><br><span class="line"><span class="number">2.</span>根据<span class="type">Replica</span>对象找到对应的<span class="type">Log</span>对象,然后调用其read()从指定位置读取数据</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按offset从tp列表中读取相应的数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readRecords</span></span>(fetchOffset: <span class="type">Long</span>,</span><br><span class="line">                  currentLeaderEpoch: <span class="type">Optional</span>[<span class="type">Integer</span>],</span><br><span class="line">                  maxBytes: <span class="type">Int</span>,</span><br><span class="line">                  fetchIsolation: <span class="type">FetchIsolation</span>,</span><br><span class="line">                  fetchOnlyFromLeader: <span class="type">Boolean</span>,</span><br><span class="line">                  minOneMessage: <span class="type">Boolean</span>): <span class="type">LogReadInfo</span> = inReadLock(leaderIsrUpdateLock) &#123;</span><br><span class="line">    <span class="comment">// 获取相应的Replica对象</span></span><br><span class="line">    <span class="keyword">val</span> localReplica = localReplicaWithEpochOrException(currentLeaderEpoch, fetchOnlyFromLeader)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> initialHighWatermark = localReplica.highWatermark.messageOffset</span><br><span class="line">    <span class="keyword">val</span> initialLogStartOffset = localReplica.logStartOffset</span><br><span class="line">    <span class="keyword">val</span> initialLogEndOffset = localReplica.logEndOffset.messageOffset</span><br><span class="line">    <span class="keyword">val</span> initialLastStableOffset = localReplica.lastStableOffset.messageOffset</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取hw位置,副本同步不用设置这个值</span></span><br><span class="line">    <span class="keyword">val</span> maxOffsetOpt = fetchIsolation <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">FetchLogEnd</span> =&gt; <span class="type">None</span></span><br><span class="line">      <span class="keyword">case</span> <span class="type">FetchHighWatermark</span> =&gt; <span class="type">Some</span>(initialHighWatermark)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">FetchTxnCommitted</span> =&gt; <span class="type">Some</span>(initialLastStableOffset)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> fetchedData = localReplica.log <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Some</span>(log) =&gt;</span><br><span class="line">        <span class="comment">// 从指定的offset读取数据,副本同步不需要maxOffsetOpt</span></span><br><span class="line">        log.read(fetchOffset, maxBytes, maxOffsetOpt, minOneMessage,</span><br><span class="line">          includeAbortedTxns = fetchIsolation == <span class="type">FetchTxnCommitted</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="type">None</span> =&gt;</span><br><span class="line">        error(<span class="string">s&quot;Leader does not have a local log&quot;</span>)</span><br><span class="line">        <span class="type">FetchDataInfo</span>(<span class="type">LogOffsetMetadata</span>.<span class="type">UnknownOffsetMetadata</span>, <span class="type">MemoryRecords</span>.<span class="type">EMPTY</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">LogReadInfo</span>(</span><br><span class="line">      fetchedData = fetchedData,</span><br><span class="line">      highWatermark = initialHighWatermark,</span><br><span class="line">      logStartOffset = initialLogStartOffset,</span><br><span class="line">      logEndOffset = initialLogEndOffset,</span><br><span class="line">      lastStableOffset = initialLastStableOffset)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="存储层"><a href="#存储层" class="headerlink" title="存储层"></a>存储层</h2><h3 id="Log对象"><a href="#Log对象" class="headerlink" title="Log对象"></a>Log对象</h3><h4 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>根据要读取的起始偏移量(startOffset)读取offset索引文件中对应的物理位置</span><br><span class="line"><span class="number">2.</span>查找offset索引文件最后返回,起始偏移量对应的最近物理位置(startPosition)</span><br><span class="line"><span class="number">3.</span>根据startPosition指定定位到数据文件,然后读取数据文件内容</span><br><span class="line"><span class="number">4.</span>最多能读到数据文件的结束位置</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从指定offset开始读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span></span>(startOffset: <span class="type">Long</span>,</span><br><span class="line">           maxLength: <span class="type">Int</span>,</span><br><span class="line">           maxOffset: <span class="type">Option</span>[<span class="type">Long</span>],</span><br><span class="line">           minOneMessage: <span class="type">Boolean</span>,</span><br><span class="line">           includeAbortedTxns: <span class="type">Boolean</span>): <span class="type">FetchDataInfo</span> = &#123;</span><br><span class="line">    maybeHandleIOException(<span class="string">s&quot;Exception while reading from <span class="subst">$topicPartition</span> in dir <span class="subst">$&#123;dir.getParent&#125;</span>&quot;</span>) &#123;</span><br><span class="line">      trace(<span class="string">s&quot;Reading <span class="subst">$maxLength</span> bytes from offset <span class="subst">$startOffset</span> of length <span class="subst">$size</span> bytes&quot;</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Because we don&#x27;t use lock for reading, the synchronization is a little bit tricky.</span></span><br><span class="line">      <span class="comment">// We create the local variables to avoid race conditions with updates to the log.</span></span><br><span class="line">      <span class="keyword">val</span> currentNextOffsetMetadata = nextOffsetMetadata</span><br><span class="line">      <span class="keyword">val</span> next = currentNextOffsetMetadata.messageOffset</span><br><span class="line">      <span class="keyword">if</span> (startOffset == next) &#123;</span><br><span class="line">        <span class="keyword">val</span> abortedTransactions =</span><br><span class="line">          <span class="keyword">if</span> (includeAbortedTxns) <span class="type">Some</span>(<span class="type">List</span>.empty[<span class="type">AbortedTransaction</span>])</span><br><span class="line">          <span class="keyword">else</span> <span class="type">None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">FetchDataInfo</span>(currentNextOffsetMetadata, <span class="type">MemoryRecords</span>.<span class="type">EMPTY</span>, firstEntryIncomplete = <span class="literal">false</span>,</span><br><span class="line">          abortedTransactions = abortedTransactions)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 查找对应的日志分段</span></span><br><span class="line">      <span class="keyword">var</span> segmentEntry = segments.floorEntry(startOffset)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// return error on attempt to read beyond the log end offset or read below log start offset</span></span><br><span class="line">      <span class="keyword">if</span> (startOffset &gt; next || segmentEntry == <span class="literal">null</span> || startOffset &lt; logStartOffset)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">OffsetOutOfRangeException</span>(<span class="string">s&quot;Received request for offset <span class="subst">$startOffset</span> for partition <span class="subst">$topicPartition</span>, &quot;</span> +</span><br><span class="line">          <span class="string">s&quot;but we only have log segments in the range <span class="subst">$logStartOffset</span> to <span class="subst">$next</span>.&quot;</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (segmentEntry != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> segment = segmentEntry.getValue</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果fetch请求刚好发生在the active segment上</span></span><br><span class="line">        <span class="comment">// 当多个Fetch请求同时处理,如果nextOffsetMetadata更新不及时</span></span><br><span class="line">        <span class="comment">// 可能会导致发送OffsetOutOfRangeException异常</span></span><br><span class="line">        <span class="comment">// 为了解决这个问题,这里能读取的最大位置是对应的物理位置(exposedPos),而不是the log end of the active segment</span></span><br><span class="line">        <span class="keyword">val</span> maxPosition = &#123;</span><br><span class="line">          <span class="keyword">if</span> (segmentEntry == segments.lastEntry) &#123;</span><br><span class="line">            <span class="comment">// nextOffsetMetadata对应的实际物理位置</span></span><br><span class="line">            <span class="keyword">val</span> exposedPos = nextOffsetMetadata.relativePositionInSegment.toLong</span><br><span class="line">            <span class="comment">// Check the segment again in case a new segment has just rolled out.</span></span><br><span class="line">            <span class="comment">// 可能会有新的segment产生,所以需要再次判断</span></span><br><span class="line">            <span class="keyword">if</span> (segmentEntry != segments.lastEntry)</span><br><span class="line">            <span class="comment">// New log segment has rolled out, we can read up to the file end.</span></span><br><span class="line">              segment.size</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              exposedPos</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            segment.size</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从segment中读取相应的数据</span></span><br><span class="line">        <span class="keyword">val</span> fetchInfo = segment.read(startOffset, maxOffset, maxLength, maxPosition, minOneMessage)</span><br><span class="line">        <span class="comment">// 如果该日志分段没有读取到数据,则读取更高的日志分段</span></span><br><span class="line">        <span class="keyword">if</span> (fetchInfo == <span class="literal">null</span>) &#123;</span><br><span class="line">          segmentEntry = segments.higherEntry(segmentEntry.getKey)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">if</span> (includeAbortedTxns)</span><br><span class="line">            addAbortedTransactions(startOffset, segmentEntry, fetchInfo)</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            fetchInfo</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// okay we are beyond the end of the last segment with no data fetched although the start offset is in range,</span></span><br><span class="line">      <span class="comment">// this can happen when all messages with offset larger than start offsets have been deleted.</span></span><br><span class="line">      <span class="comment">// In this case, we will return the empty set with log end offset metadata</span></span><br><span class="line">      <span class="type">FetchDataInfo</span>(nextOffsetMetadata, <span class="type">MemoryRecords</span>.<span class="type">EMPTY</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LogSegment对象"><a href="#LogSegment对象" class="headerlink" title="LogSegment对象"></a>LogSegment对象</h3><h4 id="read-1"><a href="#read-1" class="headerlink" title="read()"></a>read()</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>根据startOffset得到实际的物理位置(translateOffset())</span><br><span class="line"><span class="number">2.</span>计算要读取的实际物理长度</span><br><span class="line"><span class="number">3.</span>根据实际起始物理位置和要读取实际物理长度读取数据文件</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取日志分段(副本同步不会设置maxSize)</span></span><br><span class="line"><span class="meta">@threadsafe</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span></span>(startOffset: <span class="type">Long</span>, maxOffset: <span class="type">Option</span>[<span class="type">Long</span>], maxSize: <span class="type">Int</span>, maxPosition: <span class="type">Long</span> = size,</span><br><span class="line">           minOneMessage: <span class="type">Boolean</span> = <span class="literal">false</span>): <span class="type">FetchDataInfo</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (maxSize &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">s&quot;Invalid max size <span class="subst">$maxSize</span> for log read from segment <span class="subst">$log</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// log文件的物理长度</span></span><br><span class="line">    <span class="keyword">val</span> logSize = log.sizeInBytes <span class="comment">// this may change, need to save a consistent copy</span></span><br><span class="line">    <span class="comment">// 将起始的offset转换为起始的实际物理位置</span></span><br><span class="line">    <span class="keyword">val</span> startOffsetAndSize = translateOffset(startOffset)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if the start position is already off the end of the log, return null</span></span><br><span class="line">    <span class="keyword">if</span> (startOffsetAndSize == <span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> startPosition = startOffsetAndSize.position</span><br><span class="line">    <span class="keyword">val</span> offsetMetadata = <span class="keyword">new</span> <span class="type">LogOffsetMetadata</span>(startOffset, <span class="keyword">this</span>.baseOffset, startPosition)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> adjustedMaxSize =</span><br><span class="line">      <span class="keyword">if</span> (minOneMessage) math.max(maxSize, startOffsetAndSize.size)</span><br><span class="line">      <span class="keyword">else</span> maxSize</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return a log segment but with zero size in the case below</span></span><br><span class="line">    <span class="keyword">if</span> (adjustedMaxSize == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="type">FetchDataInfo</span>(offsetMetadata, <span class="type">MemoryRecords</span>.<span class="type">EMPTY</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate the length of the message set to read based on whether or not they gave us a maxOffset</span></span><br><span class="line">    <span class="comment">// 计算读取的长度</span></span><br><span class="line">    <span class="keyword">val</span> fetchSize: <span class="type">Int</span> = maxOffset <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="comment">// 副本同步时计算方式</span></span><br><span class="line">      <span class="keyword">case</span> <span class="type">None</span> =&gt;</span><br><span class="line">        <span class="comment">// no max offset, just read until the max position</span></span><br><span class="line">        <span class="comment">// 直接读最大的位置</span></span><br><span class="line">        min((maxPosition - startPosition).toInt, adjustedMaxSize)</span><br><span class="line">      <span class="comment">// consumer拉取时计算方式</span></span><br><span class="line">      <span class="keyword">case</span> <span class="type">Some</span>(offset) =&gt;</span><br><span class="line">        <span class="comment">// there is a max offset, translate it to a file position and use that to calculate the max read size;</span></span><br><span class="line">        <span class="comment">// when the leader of a partition changes, it&#x27;s possible for the new leader&#x27;s high watermark to be less than the</span></span><br><span class="line">        <span class="comment">// true high watermark in the previous leader for a short window. In this window, if a consumer fetches on an</span></span><br><span class="line">        <span class="comment">// offset between new leader&#x27;s high watermark and the log end offset, we want to return an empty response.</span></span><br><span class="line">        <span class="keyword">if</span> (offset &lt; startOffset)</span><br><span class="line">          <span class="keyword">return</span> <span class="type">FetchDataInfo</span>(offsetMetadata, <span class="type">MemoryRecords</span>.<span class="type">EMPTY</span>, firstEntryIncomplete = <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">val</span> mapping = translateOffset(offset, startPosition)</span><br><span class="line">        <span class="keyword">val</span> endPosition =</span><br><span class="line">          <span class="keyword">if</span> (mapping == <span class="literal">null</span>)</span><br><span class="line">            logSize <span class="comment">// the max offset is off the end of the log, use the end of the file</span></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            mapping.position</span><br><span class="line">        min(min(maxPosition, endPosition) - startPosition, adjustedMaxSize).toInt</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据起始的物理位置和读取长度读取数据文件</span></span><br><span class="line">    <span class="type">FetchDataInfo</span>(offsetMetadata, log.slice(startPosition, fetchSize),</span><br><span class="line">      firstEntryIncomplete = adjustedMaxSize &lt; startOffsetAndSize.size)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="translateOffset"><a href="#translateOffset" class="headerlink" title="translateOffset()"></a>translateOffset()</h4><p>具体计算方法可以参考&lt;Kafka技术内幕&gt;</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>查找offset索引文件: 调用offset索引文件的lookup()查找方法,获取里startOffset最接近的物理位置</span><br><span class="line"><span class="number">2.</span>调用数据文件的searchFor()方法,从指定的物理位置开始读取每条数据,直到找到对应的offset的物理位置</span><br><span class="line"></span><br><span class="line"><span class="meta">@threadsafe</span></span><br><span class="line"><span class="keyword">private</span>[log] <span class="function"><span class="keyword">def</span> <span class="title">translateOffset</span></span>(offset: <span class="type">Long</span>, startingFilePosition: <span class="type">Int</span> = <span class="number">0</span>): <span class="type">LogOffsetPosition</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> mapping = offsetIndex.lookup(offset)</span><br><span class="line">  log.searchForOffsetWithSize(offset, max(mapping.position, startingFilePosition))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找索引文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lookup</span></span>(targetOffset: <span class="type">Long</span>): <span class="type">OffsetPosition</span> = &#123;</span><br><span class="line">  <span class="comment">// 查找小于等于指定offset的最大offset,并且返回对应的offset和实际物理位置</span></span><br><span class="line">  maybeLock(lock) &#123;</span><br><span class="line">    <span class="keyword">val</span> idx = mmap.duplicate <span class="comment">// 查询时,mmap会发生变化,先复制一个</span></span><br><span class="line">    <span class="keyword">val</span> slot = largestLowerBoundSlotFor(idx, targetOffset, <span class="type">IndexSearchType</span>.<span class="type">KEY</span>) <span class="comment">// 二分查找</span></span><br><span class="line">    <span class="keyword">if</span>(slot == <span class="number">-1</span>)</span><br><span class="line">      <span class="type">OffsetPosition</span>(baseOffset, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment">// 计算绝对偏移量,在计算物理位置</span></span><br><span class="line">      parseEntry(idx, slot).asInstanceOf[<span class="type">OffsetPosition</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">parseEntry</span></span>(buffer: <span class="type">ByteBuffer</span>, n: <span class="type">Int</span>): <span class="type">IndexEntry</span> = &#123;</span><br><span class="line">    <span class="type">OffsetPosition</span>(baseOffset + relativeOffset(buffer, n), physical(buffer, n))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">relativeOffset</span></span>(buffer: <span class="type">ByteBuffer</span>, n: <span class="type">Int</span>): <span class="type">Int</span> = buffer.getInt(n * entrySize)</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">physical</span></span>(buffer: <span class="type">ByteBuffer</span>, n: <span class="type">Int</span>): <span class="type">Int</span> = buffer.getInt(n * entrySize + <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据文件查找,前面找到的物理位置是一个接近值</span></span><br><span class="line">public <span class="type">LogOffsetPosition</span> searchForOffsetWithSize(long targetOffset, int startingPosition) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">FileChannelRecordBatch</span> batch : batchesFrom(startingPosition)) &#123;</span><br><span class="line">        long offset = batch.lastOffset();</span><br><span class="line">        <span class="keyword">if</span> (offset &gt;= targetOffset)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">LogOffsetPosition</span>(offset, batch.position(), batch.sizeInBytes());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/kafka/" rel="tag"># kafka</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/05/08/Kafka%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8D%81%E5%89%AF%E6%9C%AC%E7%AE%A1%E7%90%86%E5%86%99%E5%85%A5/" rel="prev" title="Kafka源码系列之十副本管理写入">
                  <i class="fa fa-chevron-left"></i> Kafka源码系列之十副本管理写入
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/05/08/Kafka%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8D%81%E4%BA%8C%E5%89%AF%E6%9C%AC%E5%90%8C%E6%AD%A5%E7%BA%BF%E7%A8%8B/" rel="next" title="Kafka源码系列之十二副本同步线程">
                  Kafka源码系列之十二副本同步线程 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">X&Z</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>






  





</body>
</html>
