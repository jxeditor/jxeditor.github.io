<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<title>
  
    Kafka源码系列之十一副本管理读取
  
</title>

<meta name="description" content="Kafka处理Fetch请求以及日志读取过程">
<meta name="keywords" content="kafka">
<meta property="og:type" content="article">
<meta property="og:title" content="Kafka源码系列之十一副本管理读取">
<meta property="og:url" content="http://yoursite.com/2020/05/08/Kafka源码系列之十一副本管理读取/index.html">
<meta property="og:site_name" content="BlackC">
<meta property="og:description" content="Kafka处理Fetch请求以及日志读取过程">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-05-08T07:17:57.744Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kafka源码系列之十一副本管理读取">
<meta name="twitter:description" content="Kafka处理Fetch请求以及日志读取过程">


  <link rel="alternative" href="/atom.xml" title="BlackC" type="application/atom+xml">



  <link rel="icon" href="/images/favicon.ico">


<link rel="stylesheet" href="/perfect-scrollbar/css/perfect-scrollbar.min.css">
<link rel="stylesheet" href="/styles/main.css">






</head>
<body class="monochrome">
  <div class="mobile-header">
  <button class="sidebar-toggle" type="button">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
  </button>
  <a class="title" href="/">BlackC</a>
</div>

  <div class="main-container">
    <div class="sidebar">
  <div class="header">
    <h1 class="title"><a href="/">BlackC</a></h1>
    
    <div class="info">
      <div class="content">
        
        
          <div class="author">X&amp;Z</div>
        
      </div>
      
        <div class="avatar">
          
            <a href="/about"><img src="https://raw.githubusercontent.com/jxeditor/Software/master/Blog/logo.jpg"></a>
          
        </div>
      
    </div>
  </div>
  <div class="body">
    
      
        <ul class="nav">
          
            
              <li class="category-list-container">
                <a href="javascript:;">分类</a>
                <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/大数据/">大数据</a><span class="category-list-count">122</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/搭建/">搭建</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/教程/">教程</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/系统/">系统</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/编译/">编译</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/编辑器/">编辑器</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/运维/">运维</a><span class="category-list-count">10</span></li></ul>
              </li>
            
          
            
              <li class="tag-list-container">
                <a href="javascript:;">标签</a>
                <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithm/">algorithm</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cas/">cas</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cdh/">cdh</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/edit/">edit</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/elk/">elk</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flink/">flink</a><span class="tag-list-count">66</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/grafana/">grafana</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hbase/">hbase</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hive/">hive</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/interview/">interview</a><span class="tag-list-count">13</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kafka/">kafka</a><span class="tag-list-count">27</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kylin/">kylin</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/">maven</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mr/">mr</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/neo4j/">neo4j</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/os/">os</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oss/">oss</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/prometheus/">prometheus</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sbt/">sbt</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/">shell</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spark/">spark</a><span class="tag-list-count">15</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tomcat/">tomcat</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tools/">tools</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xwiki/">xwiki</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/zk/">zk</a><span class="tag-list-count">1</span></li></ul>
              </li>
            
          
            
              <li class="archive-list-container">
                <a href="javascript:;">归档</a>
                <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">48</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a><span class="archive-list-count">80</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">2018</a><span class="archive-list-count">17</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017</a><span class="archive-list-count">18</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/">2016</a><span class="archive-list-count">10</span></li></ul>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="/" title="主页">主页</a>
              </li>
            
          
            
              <li>
                <a href="/archives" title="文章">文章</a>
              </li>
            
          
            
              <li>
                <a href="/about" title="关于">关于</a>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="https://github.com/denjones/hexo-theme-chan" title="样式" target="_blank" rel="noopener">样式</a>
              </li>
            
          
            
              <li>
                <a href="https://github.com/jxeditor" title="Github" target="_blank" rel="noopener">Github</a>
              </li>
            
          
            
              <li>
                <a href="/atom.xml" title="RSS">RSS</a>
              </li>
            
          
        </ul>
      
    
  </div>
</div>

    <div class="main-content">
      
        <div style="max-width: 1000px">
      
          <article id="post-Kafka源码系列之十一副本管理读取" class="article article-type-post">
  
    <h1 class="article-header">
      Kafka源码系列之十一副本管理读取
    </h1>
  
  

  <div class="article-info">
    <span class="article-date">
  2020-05-08
</span>

    
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/大数据/">大数据</a></li></ul>
	</span>


    
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kafka/">kafka</a></li></ul>
	</span>


  </div>
  <div class="article-entry">
    <blockquote>
<p>Kafka处理Fetch请求以及日志读取过程</p>
</blockquote>
<a id="more"></a>
<h2 id="Fetch请求的来源"><a href="#Fetch请求的来源" class="headerlink" title="Fetch请求的来源"></a>Fetch请求的来源</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.Consumer消费数据产生Fetch请求</span><br><span class="line">    Consumer产生Fetch请求在之前有说过,在poll方法中构建</span><br><span class="line">2.副本同步Fetch请求</span><br><span class="line">    ReplicaManager中有一个ReplicaFetchManager实例负责开启FetchThread进行Fetch请求构建</span><br><span class="line"></span><br><span class="line">两者的区别:</span><br><span class="line">    Replica在构造FetchRequest时,调用了setReplicaId()设置了对应的replicaId</span><br><span class="line">    Consumer没有进行设置,默认为CONSUMER_REPLICA_ID,为-1</span><br><span class="line">    这个值就是区分Consumer的Fetch请求和Replica的Fetch请求的关键值</span><br></pre></td></tr></table></figure>
<h3 id="Consumer构建"><a href="#Consumer构建" class="headerlink" title="Consumer构建"></a>Consumer构建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fetcher.sendFetches()</span></span><br><span class="line"><span class="keyword">final</span> FetchRequest.Builder request = FetchRequest.Builder</span><br><span class="line">        .forConsumer(<span class="keyword">this</span>.maxWaitMs, <span class="keyword">this</span>.minBytes, data.toSend())</span><br><span class="line">        .isolationLevel(isolationLevel)</span><br><span class="line">        .setMaxBytes(<span class="keyword">this</span>.maxBytes)</span><br><span class="line">        .metadata(data.metadata())</span><br><span class="line">        .toForget(data.toForget());</span><br></pre></td></tr></table></figure>
<h3 id="ReplicaFetchManager构建"><a href="#ReplicaFetchManager构建" class="headerlink" title="ReplicaFetchManager构建"></a>ReplicaFetchManager构建</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReplicaFetcherThread.buildFetch()</span></span><br><span class="line"><span class="keyword">val</span> fetchData = builder.build()</span><br><span class="line"><span class="keyword">val</span> fetchRequestOpt = <span class="keyword">if</span> (fetchData.sessionPartitions.isEmpty &amp;&amp; fetchData.toForget.isEmpty) &#123;</span><br><span class="line">  <span class="type">None</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">val</span> requestBuilder = <span class="type">FetchRequest</span>.<span class="type">Builder</span></span><br><span class="line">    .forReplica(fetchRequestVersion, replicaId, maxWait, minBytes, fetchData.toSend)</span><br><span class="line">    .setMaxBytes(maxBytes)</span><br><span class="line">    .toForget(fetchData.toForget)</span><br><span class="line">    .metadata(fetchData.metadata)</span><br><span class="line">  <span class="type">Some</span>(requestBuilder)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Server端处理Fetch请求"><a href="#Server端处理Fetch请求" class="headerlink" title="Server端处理Fetch请求"></a>Server端处理Fetch请求</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApiKeys.FETCH -&gt; handleFetchRequest()</span><br></pre></td></tr></table></figure>
<h3 id="handleFetchRequest"><a href="#handleFetchRequest" class="headerlink" title="handleFetchRequest()"></a>handleFetchRequest()</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleFetchRequest</span></span>(request: <span class="type">RequestChannel</span>.<span class="type">Request</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> versionId = request.header.apiVersion</span><br><span class="line">    <span class="keyword">val</span> clientId = request.header.clientId</span><br><span class="line">    <span class="keyword">val</span> fetchRequest = request.body[<span class="type">FetchRequest</span>]</span><br><span class="line">    <span class="keyword">val</span> fetchContext = fetchManager.newContext(</span><br><span class="line">      fetchRequest.metadata,</span><br><span class="line">      fetchRequest.fetchData,</span><br><span class="line">      fetchRequest.toForget,</span><br><span class="line">      fetchRequest.isFromFollower)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检验错误的请求</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">errorResponse</span></span>[<span class="type">T</span> &gt;: <span class="type">MemoryRecords</span> &lt;: <span class="type">BaseRecords</span>](error: <span class="type">Errors</span>): <span class="type">FetchResponse</span>.<span class="type">PartitionData</span>[<span class="type">T</span>] = &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="type">FetchResponse</span>.<span class="type">PartitionData</span>[<span class="type">T</span>](error, <span class="type">FetchResponse</span>.<span class="type">INVALID_HIGHWATERMARK</span>, <span class="type">FetchResponse</span>.<span class="type">INVALID_LAST_STABLE_OFFSET</span>,</span><br><span class="line">        <span class="type">FetchResponse</span>.<span class="type">INVALID_LOG_START_OFFSET</span>, <span class="literal">null</span>, <span class="type">MemoryRecords</span>.<span class="type">EMPTY</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> erroneous = mutable.<span class="type">ArrayBuffer</span>[(<span class="type">TopicPartition</span>, <span class="type">FetchResponse</span>.<span class="type">PartitionData</span>[<span class="type">Records</span>])]()</span><br><span class="line">    <span class="keyword">val</span> interesting = mutable.<span class="type">ArrayBuffer</span>[(<span class="type">TopicPartition</span>, <span class="type">FetchRequest</span>.<span class="type">PartitionData</span>)]()</span><br><span class="line">    <span class="keyword">if</span> (fetchRequest.isFromFollower) &#123;</span><br><span class="line">      <span class="comment">// The follower must have ClusterAction on ClusterResource in order to fetch partition data.</span></span><br><span class="line">      <span class="comment">// 检验tp是否存在以及是否有Describe权限</span></span><br><span class="line">      <span class="keyword">if</span> (authorize(request.session, <span class="type">ClusterAction</span>, <span class="type">Resource</span>.<span class="type">ClusterResource</span>)) &#123;</span><br><span class="line">        fetchContext.foreachPartition &#123; (topicPartition, data) =&gt;</span><br><span class="line">          <span class="comment">// 不存在或没有Describe权限的topic,返回UNKNOWN_TOPIC_OR_PARTITION错误</span></span><br><span class="line">          <span class="keyword">if</span> (!metadataCache.contains(topicPartition))</span><br><span class="line">            erroneous += topicPartition -&gt; errorResponse(<span class="type">Errors</span>.<span class="type">UNKNOWN_TOPIC_OR_PARTITION</span>)</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            interesting += (topicPartition -&gt; data)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没有ClusterAction权限,返回TOPIC_AUTHORIZATION_FAILED错误</span></span><br><span class="line">        fetchContext.foreachPartition &#123; (part, _) =&gt;</span><br><span class="line">          erroneous += part -&gt; errorResponse(<span class="type">Errors</span>.<span class="type">TOPIC_AUTHORIZATION_FAILED</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fetchContext.foreachPartition &#123; (topicPartition, data) =&gt;</span><br><span class="line">        <span class="keyword">if</span> (!authorize(request.session, <span class="type">Read</span>, <span class="type">Resource</span>(<span class="type">Topic</span>, topicPartition.topic, <span class="type">LITERAL</span>)))</span><br><span class="line">          <span class="comment">// 没有read权限,返回TOPIC_AUTHORIZATION_FAILED错误</span></span><br><span class="line">          erroneous += topicPartition -&gt; errorResponse(<span class="type">Errors</span>.<span class="type">TOPIC_AUTHORIZATION_FAILED</span>)</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!metadataCache.contains(topicPartition))</span><br><span class="line">          <span class="comment">// 不存在或没有Describe权限的topic,返回UNKNOWN_TOPIC_OR_PARTITION错误</span></span><br><span class="line">          erroneous += topicPartition -&gt; errorResponse(<span class="type">Errors</span>.<span class="type">UNKNOWN_TOPIC_OR_PARTITION</span>)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          interesting += (topicPartition -&gt; data)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (interesting.isEmpty)</span><br><span class="line">      processResponseCallback(<span class="type">Seq</span>.empty)</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// call the replica manager to fetch messages from the local replica</span></span><br><span class="line">      <span class="comment">// 从replica上拉取数据,满足条件后调用函数进行返回</span></span><br><span class="line">      replicaManager.fetchMessages(</span><br><span class="line">        fetchRequest.maxWait.toLong, <span class="comment">// 拉取请求最长等待时间</span></span><br><span class="line">        fetchRequest.replicaId, <span class="comment">// ReplicaId,Consumer的为-1</span></span><br><span class="line">        fetchRequest.minBytes, <span class="comment">// 拉取请求的最小拉取字节</span></span><br><span class="line">        fetchRequest.maxBytes, <span class="comment">// 拉取请求的最大拉取字节</span></span><br><span class="line">        versionId &lt;= <span class="number">2</span>,</span><br><span class="line">        interesting,</span><br><span class="line">        replicationQuota(fetchRequest),</span><br><span class="line">        processResponseCallback,</span><br><span class="line">        fetchRequest.isolationLevel)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ReplicaManager"><a href="#ReplicaManager" class="headerlink" title="ReplicaManager"></a>ReplicaManager</h3><h4 id="fetchMessages"><a href="#fetchMessages" class="headerlink" title="fetchMessages"></a>fetchMessages</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>readFromLocalLog(): 从本地日志拉取相应的数据</span><br><span class="line"><span class="number">2.</span>判断<span class="type">Fetch</span>请求来源,如果来自副本同步,那么更新该副本的the end offset记录,如果该副本不在isr中,判断是否需要更新isr</span><br><span class="line"><span class="number">3.</span>返回结果,满足条件立即返回,否则通过延迟操作,延迟返回结果</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从leader拉取数据,等待拉取到足够的数据或者达到timeout时间后返回拉取的结果</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetchMessages</span></span>(timeout: <span class="type">Long</span>,</span><br><span class="line">                    replicaId: <span class="type">Int</span>,</span><br><span class="line">                    fetchMinBytes: <span class="type">Int</span>,</span><br><span class="line">                    fetchMaxBytes: <span class="type">Int</span>,</span><br><span class="line">                    hardMaxBytesLimit: <span class="type">Boolean</span>,</span><br><span class="line">                    fetchInfos: <span class="type">Seq</span>[(<span class="type">TopicPartition</span>, <span class="type">PartitionData</span>)],</span><br><span class="line">                    quota: <span class="type">ReplicaQuota</span> = <span class="type">UnboundedQuota</span>,</span><br><span class="line">                    responseCallback: <span class="type">Seq</span>[(<span class="type">TopicPartition</span>, <span class="type">FetchPartitionData</span>)] =&gt; <span class="type">Unit</span>,</span><br><span class="line">                    isolationLevel: <span class="type">IsolationLevel</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断请求时来自consumer还是副本同步</span></span><br><span class="line">    <span class="keyword">val</span> isFromFollower = <span class="type">Request</span>.isValidBrokerId(replicaId)</span><br><span class="line">    <span class="comment">// 默认从leader拉取</span></span><br><span class="line">    <span class="keyword">val</span> fetchOnlyFromLeader = replicaId != <span class="type">Request</span>.<span class="type">DebuggingConsumerId</span> &amp;&amp; replicaId != <span class="type">Request</span>.<span class="type">FutureLocalReplicaId</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果拉取请求来自consumer(true),只拉取HW以内的数据</span></span><br><span class="line">    <span class="comment">// 如果来自Replica,则没有限制</span></span><br><span class="line">    <span class="keyword">val</span> fetchIsolation = <span class="keyword">if</span> (isFromFollower || replicaId == <span class="type">Request</span>.<span class="type">FutureLocalReplicaId</span>)</span><br><span class="line">      <span class="type">FetchLogEnd</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isolationLevel == <span class="type">IsolationLevel</span>.<span class="type">READ_COMMITTED</span>)</span><br><span class="line">      <span class="type">FetchTxnCommitted</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="type">FetchHighWatermark</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">readFromLog</span></span>(): <span class="type">Seq</span>[(<span class="type">TopicPartition</span>, <span class="type">LogReadResult</span>)] = &#123;</span><br><span class="line">      <span class="comment">// 获取本地日志</span></span><br><span class="line">      <span class="keyword">val</span> result = readFromLocalLog(</span><br><span class="line">        replicaId = replicaId,</span><br><span class="line">        fetchOnlyFromLeader = fetchOnlyFromLeader,</span><br><span class="line">        fetchIsolation = fetchIsolation,</span><br><span class="line">        fetchMaxBytes = fetchMaxBytes,</span><br><span class="line">        hardMaxBytesLimit = hardMaxBytesLimit,</span><br><span class="line">        readPartitionInfo = fetchInfos,</span><br><span class="line">        quota = quota)</span><br><span class="line">      <span class="comment">// 如果fetch来自broker的副本同步,更新相关的log end offset</span></span><br><span class="line">      <span class="keyword">if</span> (isFromFollower) updateFollowerLogReadResults(replicaId, result)</span><br><span class="line">      <span class="keyword">else</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> logReadResults = readFromLog()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check if this fetch request can be satisfied right away</span></span><br><span class="line">    <span class="keyword">val</span> logReadResultValues = logReadResults.map &#123; <span class="keyword">case</span> (_, v) =&gt; v &#125;</span><br><span class="line">    <span class="keyword">val</span> bytesReadable = logReadResultValues.map(_.info.records.sizeInBytes).sum</span><br><span class="line">    <span class="keyword">val</span> errorReadingData = logReadResultValues.foldLeft(<span class="literal">false</span>) ((errorIncurred, readResult) =&gt;</span><br><span class="line">      errorIncurred || (readResult.error != <span class="type">Errors</span>.<span class="type">NONE</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果满足以下条件的其中一个,立马返回结果</span></span><br><span class="line">    <span class="comment">// 1.timeout达到</span></span><br><span class="line">    <span class="comment">// 2.拉取结果为空</span></span><br><span class="line">    <span class="comment">// 3.拉取到足够的数据</span></span><br><span class="line">    <span class="comment">// 4.拉取时遇到Error</span></span><br><span class="line">    <span class="keyword">if</span> (timeout &lt;= <span class="number">0</span> || fetchInfos.isEmpty || bytesReadable &gt;= fetchMinBytes || errorReadingData) &#123;</span><br><span class="line">      <span class="keyword">val</span> fetchPartitionData = logReadResults.map &#123; <span class="keyword">case</span> (tp, result) =&gt;</span><br><span class="line">        tp -&gt; <span class="type">FetchPartitionData</span>(result.error, result.highWatermark, result.leaderLogStartOffset, result.info.records,</span><br><span class="line">          result.lastStableOffset, result.info.abortedTransactions)</span><br><span class="line">      &#125;</span><br><span class="line">      responseCallback(fetchPartitionData)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// construct the fetch results from the read results</span></span><br><span class="line">      <span class="comment">// 延迟发送结果</span></span><br><span class="line">      <span class="keyword">val</span> fetchPartitionStatus = logReadResults.map &#123; <span class="keyword">case</span> (topicPartition, result) =&gt;</span><br><span class="line">        <span class="keyword">val</span> fetchInfo = fetchInfos.collectFirst &#123;</span><br><span class="line">          <span class="keyword">case</span> (tp, v) <span class="keyword">if</span> tp == topicPartition =&gt; v</span><br><span class="line">        &#125;.getOrElse(sys.error(<span class="string">s"Partition <span class="subst">$topicPartition</span> not found in fetchInfos"</span>))</span><br><span class="line">        (topicPartition, <span class="type">FetchPartitionStatus</span>(result.info.fetchOffsetMetadata, fetchInfo))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">val</span> fetchMetadata = <span class="type">FetchMetadata</span>(fetchMinBytes, fetchMaxBytes, hardMaxBytesLimit, fetchOnlyFromLeader,</span><br><span class="line">        fetchIsolation, isFromFollower, replicaId, fetchPartitionStatus)</span><br><span class="line">      <span class="keyword">val</span> delayedFetch = <span class="keyword">new</span> <span class="type">DelayedFetch</span>(timeout, fetchMetadata, <span class="keyword">this</span>, quota, responseCallback)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// create a list of (topic, partition) pairs to use as keys for this delayed fetch operation</span></span><br><span class="line">      <span class="keyword">val</span> delayedFetchKeys = fetchPartitionStatus.map &#123; <span class="keyword">case</span> (tp, _) =&gt; <span class="keyword">new</span> <span class="type">TopicPartitionOperationKey</span>(tp) &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// try to complete the request immediately, otherwise put it into the purgatory;</span></span><br><span class="line">      <span class="comment">// this is because while the delayed fetch operation is being created, new requests</span></span><br><span class="line">      <span class="comment">// may arrive and hence make this operation completable.</span></span><br><span class="line">      delayedFetchPurgatory.tryCompleteElseWatch(delayedFetch, delayedFetchKeys)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="readFromLocalLog-gt-readRecords"><a href="#readFromLocalLog-gt-readRecords" class="headerlink" title="readFromLocalLog()-&gt;readRecords()"></a>readFromLocalLog()-&gt;readRecords()</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>先根据要拉取的tp获取对应的partition对象,根据partition对象获取对应的<span class="type">Replica</span>对象</span><br><span class="line"><span class="number">2.</span>根据<span class="type">Replica</span>对象找到对应的<span class="type">Log</span>对象,然后调用其read()从指定位置读取数据</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按offset从tp列表中读取相应的数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readRecords</span></span>(fetchOffset: <span class="type">Long</span>,</span><br><span class="line">                  currentLeaderEpoch: <span class="type">Optional</span>[<span class="type">Integer</span>],</span><br><span class="line">                  maxBytes: <span class="type">Int</span>,</span><br><span class="line">                  fetchIsolation: <span class="type">FetchIsolation</span>,</span><br><span class="line">                  fetchOnlyFromLeader: <span class="type">Boolean</span>,</span><br><span class="line">                  minOneMessage: <span class="type">Boolean</span>): <span class="type">LogReadInfo</span> = inReadLock(leaderIsrUpdateLock) &#123;</span><br><span class="line">    <span class="comment">// 获取相应的Replica对象</span></span><br><span class="line">    <span class="keyword">val</span> localReplica = localReplicaWithEpochOrException(currentLeaderEpoch, fetchOnlyFromLeader)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> initialHighWatermark = localReplica.highWatermark.messageOffset</span><br><span class="line">    <span class="keyword">val</span> initialLogStartOffset = localReplica.logStartOffset</span><br><span class="line">    <span class="keyword">val</span> initialLogEndOffset = localReplica.logEndOffset.messageOffset</span><br><span class="line">    <span class="keyword">val</span> initialLastStableOffset = localReplica.lastStableOffset.messageOffset</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取hw位置,副本同步不用设置这个值</span></span><br><span class="line">    <span class="keyword">val</span> maxOffsetOpt = fetchIsolation <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">FetchLogEnd</span> =&gt; <span class="type">None</span></span><br><span class="line">      <span class="keyword">case</span> <span class="type">FetchHighWatermark</span> =&gt; <span class="type">Some</span>(initialHighWatermark)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">FetchTxnCommitted</span> =&gt; <span class="type">Some</span>(initialLastStableOffset)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> fetchedData = localReplica.log <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Some</span>(log) =&gt;</span><br><span class="line">        <span class="comment">// 从指定的offset读取数据,副本同步不需要maxOffsetOpt</span></span><br><span class="line">        log.read(fetchOffset, maxBytes, maxOffsetOpt, minOneMessage,</span><br><span class="line">          includeAbortedTxns = fetchIsolation == <span class="type">FetchTxnCommitted</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="type">None</span> =&gt;</span><br><span class="line">        error(<span class="string">s"Leader does not have a local log"</span>)</span><br><span class="line">        <span class="type">FetchDataInfo</span>(<span class="type">LogOffsetMetadata</span>.<span class="type">UnknownOffsetMetadata</span>, <span class="type">MemoryRecords</span>.<span class="type">EMPTY</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">LogReadInfo</span>(</span><br><span class="line">      fetchedData = fetchedData,</span><br><span class="line">      highWatermark = initialHighWatermark,</span><br><span class="line">      logStartOffset = initialLogStartOffset,</span><br><span class="line">      logEndOffset = initialLogEndOffset,</span><br><span class="line">      lastStableOffset = initialLastStableOffset)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="存储层"><a href="#存储层" class="headerlink" title="存储层"></a>存储层</h2><h3 id="Log对象"><a href="#Log对象" class="headerlink" title="Log对象"></a>Log对象</h3><h4 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>根据要读取的起始偏移量(startOffset)读取offset索引文件中对应的物理位置</span><br><span class="line"><span class="number">2.</span>查找offset索引文件最后返回,起始偏移量对应的最近物理位置(startPosition)</span><br><span class="line"><span class="number">3.</span>根据startPosition指定定位到数据文件,然后读取数据文件内容</span><br><span class="line"><span class="number">4.</span>最多能读到数据文件的结束位置</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从指定offset开始读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span></span>(startOffset: <span class="type">Long</span>,</span><br><span class="line">           maxLength: <span class="type">Int</span>,</span><br><span class="line">           maxOffset: <span class="type">Option</span>[<span class="type">Long</span>],</span><br><span class="line">           minOneMessage: <span class="type">Boolean</span>,</span><br><span class="line">           includeAbortedTxns: <span class="type">Boolean</span>): <span class="type">FetchDataInfo</span> = &#123;</span><br><span class="line">    maybeHandleIOException(<span class="string">s"Exception while reading from <span class="subst">$topicPartition</span> in dir <span class="subst">$&#123;dir.getParent&#125;</span>"</span>) &#123;</span><br><span class="line">      trace(<span class="string">s"Reading <span class="subst">$maxLength</span> bytes from offset <span class="subst">$startOffset</span> of length <span class="subst">$size</span> bytes"</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Because we don't use lock for reading, the synchronization is a little bit tricky.</span></span><br><span class="line">      <span class="comment">// We create the local variables to avoid race conditions with updates to the log.</span></span><br><span class="line">      <span class="keyword">val</span> currentNextOffsetMetadata = nextOffsetMetadata</span><br><span class="line">      <span class="keyword">val</span> next = currentNextOffsetMetadata.messageOffset</span><br><span class="line">      <span class="keyword">if</span> (startOffset == next) &#123;</span><br><span class="line">        <span class="keyword">val</span> abortedTransactions =</span><br><span class="line">          <span class="keyword">if</span> (includeAbortedTxns) <span class="type">Some</span>(<span class="type">List</span>.empty[<span class="type">AbortedTransaction</span>])</span><br><span class="line">          <span class="keyword">else</span> <span class="type">None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">FetchDataInfo</span>(currentNextOffsetMetadata, <span class="type">MemoryRecords</span>.<span class="type">EMPTY</span>, firstEntryIncomplete = <span class="literal">false</span>,</span><br><span class="line">          abortedTransactions = abortedTransactions)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 查找对应的日志分段</span></span><br><span class="line">      <span class="keyword">var</span> segmentEntry = segments.floorEntry(startOffset)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// return error on attempt to read beyond the log end offset or read below log start offset</span></span><br><span class="line">      <span class="keyword">if</span> (startOffset &gt; next || segmentEntry == <span class="literal">null</span> || startOffset &lt; logStartOffset)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">OffsetOutOfRangeException</span>(<span class="string">s"Received request for offset <span class="subst">$startOffset</span> for partition <span class="subst">$topicPartition</span>, "</span> +</span><br><span class="line">          <span class="string">s"but we only have log segments in the range <span class="subst">$logStartOffset</span> to <span class="subst">$next</span>."</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (segmentEntry != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> segment = segmentEntry.getValue</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果fetch请求刚好发生在the active segment上</span></span><br><span class="line">        <span class="comment">// 当多个Fetch请求同时处理,如果nextOffsetMetadata更新不及时</span></span><br><span class="line">        <span class="comment">// 可能会导致发送OffsetOutOfRangeException异常</span></span><br><span class="line">        <span class="comment">// 为了解决这个问题,这里能读取的最大位置是对应的物理位置(exposedPos),而不是the log end of the active segment</span></span><br><span class="line">        <span class="keyword">val</span> maxPosition = &#123;</span><br><span class="line">          <span class="keyword">if</span> (segmentEntry == segments.lastEntry) &#123;</span><br><span class="line">            <span class="comment">// nextOffsetMetadata对应的实际物理位置</span></span><br><span class="line">            <span class="keyword">val</span> exposedPos = nextOffsetMetadata.relativePositionInSegment.toLong</span><br><span class="line">            <span class="comment">// Check the segment again in case a new segment has just rolled out.</span></span><br><span class="line">            <span class="comment">// 可能会有新的segment产生,所以需要再次判断</span></span><br><span class="line">            <span class="keyword">if</span> (segmentEntry != segments.lastEntry)</span><br><span class="line">            <span class="comment">// New log segment has rolled out, we can read up to the file end.</span></span><br><span class="line">              segment.size</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              exposedPos</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            segment.size</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从segment中读取相应的数据</span></span><br><span class="line">        <span class="keyword">val</span> fetchInfo = segment.read(startOffset, maxOffset, maxLength, maxPosition, minOneMessage)</span><br><span class="line">        <span class="comment">// 如果该日志分段没有读取到数据,则读取更高的日志分段</span></span><br><span class="line">        <span class="keyword">if</span> (fetchInfo == <span class="literal">null</span>) &#123;</span><br><span class="line">          segmentEntry = segments.higherEntry(segmentEntry.getKey)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">if</span> (includeAbortedTxns)</span><br><span class="line">            addAbortedTransactions(startOffset, segmentEntry, fetchInfo)</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            fetchInfo</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// okay we are beyond the end of the last segment with no data fetched although the start offset is in range,</span></span><br><span class="line">      <span class="comment">// this can happen when all messages with offset larger than start offsets have been deleted.</span></span><br><span class="line">      <span class="comment">// In this case, we will return the empty set with log end offset metadata</span></span><br><span class="line">      <span class="type">FetchDataInfo</span>(nextOffsetMetadata, <span class="type">MemoryRecords</span>.<span class="type">EMPTY</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LogSegment对象"><a href="#LogSegment对象" class="headerlink" title="LogSegment对象"></a>LogSegment对象</h3><h4 id="read-1"><a href="#read-1" class="headerlink" title="read()"></a>read()</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>根据startOffset得到实际的物理位置(translateOffset())</span><br><span class="line"><span class="number">2.</span>计算要读取的实际物理长度</span><br><span class="line"><span class="number">3.</span>根据实际起始物理位置和要读取实际物理长度读取数据文件</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取日志分段(副本同步不会设置maxSize)</span></span><br><span class="line"><span class="meta">@threadsafe</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span></span>(startOffset: <span class="type">Long</span>, maxOffset: <span class="type">Option</span>[<span class="type">Long</span>], maxSize: <span class="type">Int</span>, maxPosition: <span class="type">Long</span> = size,</span><br><span class="line">           minOneMessage: <span class="type">Boolean</span> = <span class="literal">false</span>): <span class="type">FetchDataInfo</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (maxSize &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">s"Invalid max size <span class="subst">$maxSize</span> for log read from segment <span class="subst">$log</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// log文件的物理长度</span></span><br><span class="line">    <span class="keyword">val</span> logSize = log.sizeInBytes <span class="comment">// this may change, need to save a consistent copy</span></span><br><span class="line">    <span class="comment">// 将起始的offset转换为起始的实际物理位置</span></span><br><span class="line">    <span class="keyword">val</span> startOffsetAndSize = translateOffset(startOffset)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if the start position is already off the end of the log, return null</span></span><br><span class="line">    <span class="keyword">if</span> (startOffsetAndSize == <span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> startPosition = startOffsetAndSize.position</span><br><span class="line">    <span class="keyword">val</span> offsetMetadata = <span class="keyword">new</span> <span class="type">LogOffsetMetadata</span>(startOffset, <span class="keyword">this</span>.baseOffset, startPosition)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> adjustedMaxSize =</span><br><span class="line">      <span class="keyword">if</span> (minOneMessage) math.max(maxSize, startOffsetAndSize.size)</span><br><span class="line">      <span class="keyword">else</span> maxSize</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return a log segment but with zero size in the case below</span></span><br><span class="line">    <span class="keyword">if</span> (adjustedMaxSize == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="type">FetchDataInfo</span>(offsetMetadata, <span class="type">MemoryRecords</span>.<span class="type">EMPTY</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate the length of the message set to read based on whether or not they gave us a maxOffset</span></span><br><span class="line">    <span class="comment">// 计算读取的长度</span></span><br><span class="line">    <span class="keyword">val</span> fetchSize: <span class="type">Int</span> = maxOffset <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="comment">// 副本同步时计算方式</span></span><br><span class="line">      <span class="keyword">case</span> <span class="type">None</span> =&gt;</span><br><span class="line">        <span class="comment">// no max offset, just read until the max position</span></span><br><span class="line">        <span class="comment">// 直接读最大的位置</span></span><br><span class="line">        min((maxPosition - startPosition).toInt, adjustedMaxSize)</span><br><span class="line">      <span class="comment">// consumer拉取时计算方式</span></span><br><span class="line">      <span class="keyword">case</span> <span class="type">Some</span>(offset) =&gt;</span><br><span class="line">        <span class="comment">// there is a max offset, translate it to a file position and use that to calculate the max read size;</span></span><br><span class="line">        <span class="comment">// when the leader of a partition changes, it's possible for the new leader's high watermark to be less than the</span></span><br><span class="line">        <span class="comment">// true high watermark in the previous leader for a short window. In this window, if a consumer fetches on an</span></span><br><span class="line">        <span class="comment">// offset between new leader's high watermark and the log end offset, we want to return an empty response.</span></span><br><span class="line">        <span class="keyword">if</span> (offset &lt; startOffset)</span><br><span class="line">          <span class="keyword">return</span> <span class="type">FetchDataInfo</span>(offsetMetadata, <span class="type">MemoryRecords</span>.<span class="type">EMPTY</span>, firstEntryIncomplete = <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">val</span> mapping = translateOffset(offset, startPosition)</span><br><span class="line">        <span class="keyword">val</span> endPosition =</span><br><span class="line">          <span class="keyword">if</span> (mapping == <span class="literal">null</span>)</span><br><span class="line">            logSize <span class="comment">// the max offset is off the end of the log, use the end of the file</span></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            mapping.position</span><br><span class="line">        min(min(maxPosition, endPosition) - startPosition, adjustedMaxSize).toInt</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据起始的物理位置和读取长度读取数据文件</span></span><br><span class="line">    <span class="type">FetchDataInfo</span>(offsetMetadata, log.slice(startPosition, fetchSize),</span><br><span class="line">      firstEntryIncomplete = adjustedMaxSize &lt; startOffsetAndSize.size)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="translateOffset"><a href="#translateOffset" class="headerlink" title="translateOffset()"></a>translateOffset()</h4><p>具体计算方法可以参考&lt;Kafka技术内幕&gt;<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>查找offset索引文件: 调用offset索引文件的lookup()查找方法,获取里startOffset最接近的物理位置</span><br><span class="line"><span class="number">2.</span>调用数据文件的searchFor()方法,从指定的物理位置开始读取每条数据,直到找到对应的offset的物理位置</span><br><span class="line"></span><br><span class="line"><span class="meta">@threadsafe</span></span><br><span class="line"><span class="keyword">private</span>[log] <span class="function"><span class="keyword">def</span> <span class="title">translateOffset</span></span>(offset: <span class="type">Long</span>, startingFilePosition: <span class="type">Int</span> = <span class="number">0</span>): <span class="type">LogOffsetPosition</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> mapping = offsetIndex.lookup(offset)</span><br><span class="line">  log.searchForOffsetWithSize(offset, max(mapping.position, startingFilePosition))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找索引文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lookup</span></span>(targetOffset: <span class="type">Long</span>): <span class="type">OffsetPosition</span> = &#123;</span><br><span class="line">  <span class="comment">// 查找小于等于指定offset的最大offset,并且返回对应的offset和实际物理位置</span></span><br><span class="line">  maybeLock(lock) &#123;</span><br><span class="line">    <span class="keyword">val</span> idx = mmap.duplicate <span class="comment">// 查询时,mmap会发生变化,先复制一个</span></span><br><span class="line">    <span class="keyword">val</span> slot = largestLowerBoundSlotFor(idx, targetOffset, <span class="type">IndexSearchType</span>.<span class="type">KEY</span>) <span class="comment">// 二分查找</span></span><br><span class="line">    <span class="keyword">if</span>(slot == <span class="number">-1</span>)</span><br><span class="line">      <span class="type">OffsetPosition</span>(baseOffset, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment">// 计算绝对偏移量,在计算物理位置</span></span><br><span class="line">      parseEntry(idx, slot).asInstanceOf[<span class="type">OffsetPosition</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">parseEntry</span></span>(buffer: <span class="type">ByteBuffer</span>, n: <span class="type">Int</span>): <span class="type">IndexEntry</span> = &#123;</span><br><span class="line">    <span class="type">OffsetPosition</span>(baseOffset + relativeOffset(buffer, n), physical(buffer, n))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">relativeOffset</span></span>(buffer: <span class="type">ByteBuffer</span>, n: <span class="type">Int</span>): <span class="type">Int</span> = buffer.getInt(n * entrySize)</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">physical</span></span>(buffer: <span class="type">ByteBuffer</span>, n: <span class="type">Int</span>): <span class="type">Int</span> = buffer.getInt(n * entrySize + <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据文件查找,前面找到的物理位置是一个接近值</span></span><br><span class="line">public <span class="type">LogOffsetPosition</span> searchForOffsetWithSize(long targetOffset, int startingPosition) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">FileChannelRecordBatch</span> batch : batchesFrom(startingPosition)) &#123;</span><br><span class="line">        long offset = batch.lastOffset();</span><br><span class="line">        <span class="keyword">if</span> (offset &gt;= targetOffset)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">LogOffsetPosition</span>(offset, batch.position(), batch.sizeInBytes());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

  </div>
  <footer class="article-footer">
    
  <div class="cc">
    <a href="http://creativecommons.org/licenses/by-sa/4.0/deed.z" target="_blank" title="署名-相同方式共享">
      <img src="/images/cc/cc.png">
      
          <img src="/images/cc/by.png">
        
          <img src="/images/cc/sa.png">
      
      <span>
        本作品采用知识共享 署名-相同方式共享 4.0 国际许可协议进行许可。
      </span>
    </a>
  </div>


    

  </footer>
</article>







          <div class="main-footer">
  
    © 2020 BlackC - Powered by <a href="http://hexo.io" target="_blank">Hexo</a> - Theme <a href="https://github.com/denjones/hexo-theme-chan" target="_blank">Chan</a>
  
</div>

      
        </div>
      
    </div>
  </div>
  <script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

  <link rel="stylesheet" href="/PhotoSwipe/photoswipe.css">
  <link rel="stylesheet" href="/PhotoSwipe/default-skin/default-skin.css">

  <!-- Root element of PhotoSwipe. Must have class pswp. -->
  <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe.
             It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

      <!-- Container that holds slides.
                PhotoSwipe keeps only 3 of them in the DOM to save memory.
                Don't modify these 3 pswp__item elements, data is added later on. -->
      <div class="pswp__container">
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
      </div>

      <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
      <div class="pswp__ui pswp__ui--hidden">

        <div class="pswp__top-bar">

          <!--  Controls are self-explanatory. Order can be changed. -->

          <div class="pswp__counter"></div>

          <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

          <button class="pswp__button pswp__button--share" title="Share"></button>

          <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

          <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

          <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
          <!-- element will get class pswp__preloader--active when preloader is running -->
          <div class="pswp__preloader">
            <div class="pswp__preloader__icn">
              <div class="pswp__preloader__cut">
                <div class="pswp__preloader__donut"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
          <div class="pswp__share-tooltip"></div>
        </div>

        <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>

        <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button>

        <div class="pswp__caption">
          <div class="pswp__caption__center"></div>
        </div>
      </div>
    </div>
  </div>

  <script src="/PhotoSwipe/photoswipe.js"></script>
  <script src="/PhotoSwipe/photoswipe-ui-default.js"></script>


<script src="/perfect-scrollbar/js/min/perfect-scrollbar.min.js"></script>
<script src="/scripts/main.js"></script>

</body>
</html>
