---
title: 访问者模式的使用
date: 2020-06-28 15:35:13
categories: 教程
tags: spark
---

> 访问者模式贯穿着Spark的底层源码

<!-- more -->

## 介绍
```
表示一个作用于某对象结构中的各元素的操作。
它使你可以在不改变各元素类的前提下定义作用于这些元素的新操作。
```
---

## 代码实现
```java
// 抽象访问者角色,为该对象结构中具体角色声明一个访问操作接口
// 该操作接口的名字和参数标识了发送访问请求给具体访问者的具体元素角色
// 这样访问者就可以通过该元素角色的特定接口直接访问它
public interface Visitor {
    public void visit(Beijing beijing);

    public void visit(Shanghai shanghai);

    public void visit(Shenzhen shenzhen);
}
// 抽象元素,定义一个接受访问操作,以一个访问者作为参数
public interface City {
    public void accept(Visitor visitor);
}
// 具体元素,实现了抽象元素定义的接受操作接口
public class Beijing implements City {
    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
}
public class Shanghai implements City {
    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
}
public class Shenzhen implements City {
    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
}
// 结构对象角色,使用访问者必备的角色
// 能枚举它的元素;可以提供一个高层接口以允许访问者访问他的元素;
// 如有需要,可以设计成一个符合对象或者一个聚集(列表或无序集合)
public class TravelCities implements City {
    City[] cities;

    public TravelCities() {
        cities = new City[]{new Beijing(), new Shanghai(), new Shenzhen()};
    }

    @Override
    public void accept(Visitor visitor) {
        for (int i = 0; i < cities.length; i++) {
            cities[i].accept(visitor);
        }
    }
}
// 具体访问者角色,实现Visitor声明的接口
public class SingleVisitor implements Visitor {
    @Override
    public void visit(Beijing beijing) {
        System.out.println("bj");
    }

    @Override
    public void visit(Shanghai shanghai) {
        System.out.println("sh");
    }

    @Override
    public void visit(Shenzhen shenzhen) {
        System.out.println("sz");
    }
}
// Demo
public class Demo {
    public static void main(String[] args) {
        TravelCities travelCities = new TravelCities();
        travelCities.accept(new SingleVisitor());
    }
}

```
