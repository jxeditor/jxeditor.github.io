---
title: 任务调度结合数据结构图实现
date: 2019-10-12 14:13:00
categories: 
- 算法
- 大数据
tags: algorithm
---

> 各类作业执行会操作不同的表,作业之间又有依赖关系,所以希望通过输入输出表与作业的关系来决定作业顺序,其实如果没有特殊要求,像这类调度可以使用Azkanban工具来实现,更加方便

<!-- more -->

## 已有信息
- 各spark作业jar
- neo4j存储了作业与表的关系图
- 作业有执行的先后关系

---

## 需求
- 半/全自动化执行作业
- 只需要确定输入表输出表与作业的关系,就可以生成执行信息

---

## 实现流程
```
1.Neo4j针对输入输出表,建立图
2.根据图去生成作业的执行顺序<重点>
    eg: 现有5张表,ta,tb,tc,td,te,每个表对应1个spark程序j1,j2,j3,j4,j5
    表的依赖关系为tc依赖于(ta,tb),te依赖于(tc,td),那么我们可以得到一个任务分层树
    表分层:
        第一层: ta,tb,td		
        第二层: tc							
        第三层: te							
    对应作业:	
        第一层: j1,j2,j4
        第二层: j3
        第三层: j5
3.建立作业的状态表job_state(状态信息MySQL存储)
    eg: 根据上述信息,可以了解到,树的深度是未知的,所以根据层数来指定分层表是不理想的,但是可以用父子节点的方式将作业信息存放单表中
    每个作业应该有的信息有
        作业id(每天根据第2步生成任务分层树生成)
        父作业id(依赖的作业id,无为0,,可以是多个)
        执行状态(0未执行,1,正在执行,2执行失败,6执行成功)
        执行命令(spark-submit ...jar)
        开始时间
        结束时间
4.建立脚本,每天定时执行(具体选择队列形式<celery一次执行>,还是重复执行<crontab每N分钟执行>)
5.脚本逻辑
    去表中获取今日份作业信息<循环执行>
    判断状态值与依赖
    状态为0且无父依赖
        调用console执行spark作业
    状态为0但有父依赖
        根据父作业id,查询父作业状态select * from job_state where id = 父作业id and 执行状态 != 6
        判断状态值,为6则执行,只要有不为6的就跳过
    状态不为0
        跳过执行
```

---

## 图代码实现
### Point(TablePoint,ProjectPoint)
```java
import java.util.HashSet;

public abstract class Point {
    HashSet<String> parentPoints = new HashSet<>();
    HashSet<String> childPoints = new HashSet<>();
}

// ---

public class ProjectPoint extends Point {
    @Override
    public String toString() {
        return "任务节点";
    }
}

// ---

public class TablePoint extends Point {
    @Override
    public String toString() {
        return "表节点";
    }
}
```
### Graph
```java
import java.util.HashMap;
import java.util.HashSet;

class Graph {
    private HashMap<String, Point> pointMap = new HashMap<>();
    private HashMap<String, HashSet<String>> edgeMap = new HashMap<>();
    
    /**
     * 添加节点,Point具有两个数组,分别存父节点,子节点
     *
     * @param name
     * @param point
     */
    void addPoint(String name, Point point) {
        pointMap.put(name, point);
    }

    /**
     * 添加边,并给from节点添加子节点列表,给to节点添加父节点列表
     *
     * @param from
     * @param to
     */
    void addEdge(String from, String to) {
        HashSet<String> nextPoint = edgeMap.get(from);
        if (nextPoint != null) {
            nextPoint.add(to);
        } else {
            HashSet<String> strings = new HashSet<>();
            strings.add(to);
            edgeMap.put(from, strings);
        }
        Point fromPoint = pointMap.get(from);
        Point toPoint = pointMap.get(to);
        fromPoint.childPoints.add(to);
        toPoint.parentPoints.add(from);
    }

    HashMap<String, HashSet<String>> getEdgeMap() {
        return edgeMap;
    }

    HashMap<String, Point> getPointMap() {
        return pointMap;
    }

    /**
     * 获取出度
     *
     * @return
     */
    HashMap<String, Integer> getOutDegree() {
        HashMap<String, Integer> outDegree = new HashMap<>();
        for (String key : edgeMap.keySet()) {
            outDegree.put(key, edgeMap.get(key).size());
        }
        return outDegree;
    }

    /**
     * 获取入度
     *
     * @return
     */
    HashMap<String, Integer> getInDegree() {
        HashMap<String, Integer> inDegree = new HashMap<>();
        for (String key : edgeMap.keySet()) {
            HashSet<String> strings = edgeMap.get(key);
            for (String s : strings) {
                inDegree.merge(s, 1, (a, b) -> a + b);
            }
        }
        return inDegree;
    }

    /**
     * 获取points各个节点为ProjectPoint的节点,HashSet去重
     * 目前暂且支持table->project->table的情况
     *
     * @param points
     * @return
     */
    HashSet<String> getParentNodes(HashSet<String> points) {
        HashSet<String> result = new HashSet<>();
        for (String point : points) {
            if (!(pointMap.get(point) instanceof ProjectPoint)) {
                result.addAll(getParentNodes(pointMap.get(point).parentPoints));
            } else {
                result.add(point);
            }
        }
        return result;
    }
}
```
### GraphDemo
```java
import java.util.HashMap;
import java.util.HashSet;

public class GraphDemo {
    public static void main(String[] args) {
        Graph graph = new Graph();
        // 构建图
        graph.addPoint("a", new TablePoint());
        graph.addPoint("b", new TablePoint());
        graph.addPoint("c", new TablePoint());
        graph.addPoint("d", new ProjectPoint());
        graph.addPoint("e", new TablePoint());
        graph.addPoint("f", new ProjectPoint());
        graph.addPoint("g", new TablePoint());
        graph.addPoint("h", new TablePoint());
        graph.addPoint("i", new TablePoint());
        graph.addPoint("j", new ProjectPoint());
        graph.addEdge("a", "d");
        graph.addEdge("b", "d");
        graph.addEdge("c", "d");
        graph.addEdge("d", "e");
        graph.addEdge("e", "f");
        graph.addEdge("f", "g");
        graph.addEdge("f", "h");
        graph.addEdge("g", "j");
        graph.addEdge("h", "j");
        graph.addEdge("i", "j");

        System.out.println(graph.getPointMap());
        System.out.println(graph.getEdgeMap());

        HashMap<String, HashSet<String>> edgeMap = graph.getEdgeMap();
        HashMap<String, Point> pointMap = graph.getPointMap();

        // 出度
        System.out.println(graph.getOutDegree());

        // 入度
        System.out.println(graph.getInDegree());

        // 生成ProjectPoint节点,以及其父ProjectPoint节点信息
        for (String key : pointMap.keySet()) {
            // System.out.println(key+":"+pointMap.get(key).parentPoints);
            if (pointMap.get(key) instanceof ProjectPoint) {
                HashSet<String> parentNodes = graph.getParentNodes(pointMap.get(key).parentPoints);
                System.out.println(key + ":" + parentNodes);
            }
        }
    }
}
```

---

## 图升级版实现<附思路和代码>
### 思路
```
我们已经获取了一个图,并且确定了每个节点的父节点与子节点
那么获取所有没有入度的节点
执行完没有入度的节点之后,删除节点,与其对应的边,再去获取没有入度的节点
一直循环,直到结束

点集:存放节点信息
边集:存放(from点,to点)关系对

执行节点: 
执行时,将正在执行的节点保存起来<runningNode>;
什么是执行节点,获取没有入度的节点并且不存在于<runningNode>的节点就是执行节点
没有入度的节点:遍历边集的to节点,不存在与点集的都是没有入度的节点
执行前或执行后删除都可以,顺序如下
[1,2,3,4,5,6]->[(1,2),(1,3),(4,5),(3,6),(5,6)]
to(2,3,5,6) 执行1,4
[2,3,5,6]->[(3,6),(5,6)]
to(6) 执行2,3,5
[6]->[]
to() 执行6

具体实现开启多线程执行作业
```

### 代码